{
  "language": "Solidity",
  "sources": {
    "contracts/Surpay.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.8;\n\n/**\n * @title Surpay\n * @author Keegan Anglim and Alan Abed\n * @notice This contract is meant to be a demo and should not be used\n * in production\n * @notice The purpose of this contract is to facilitate an exchange\n * of survey data for funds.\n */\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol\";\n\nerror Surpay__NotEnoughFunds();\nerror Surpay__MissingRequiredFields();\nerror Surpay__TransferFailed();\nerror Surpay__SurveyNotFound();\nerror Surpay__MaximumRespondantsReached();\nerror Surpay__NotOwner();\nerror Surpay__UpkeepNotNeeded();\nerror Surpay__SurveyAlreadyConcluded();\n\ncontract Surpay is AutomationCompatibleInterface{\n\n    /* Type Declarations  */\n\n    /**\n     * @dev Survey structs will hold the survey ID as well as a mapping for each user address, as well as payout information.\n     */\n    struct Survey{\n        \n        string companyId;\n        address companyAddress;\n        uint256 totalPayoutAmount;\n        uint256 numOfParticipantsDesired;\n        uint256 numOfParticipantsFulfilled;\n        address payable[] surveyTakers;\n        uint256 startTimeStamp;\n        SurveyState surveyState;\n    }\n    /**\n     * @dev The survey state was needed in an ealier version of the contract\n     * @dev We are leaving it in, because a get state function is used in \n     * @dev one of our unit tests.\n     */\n    enum SurveyState{\n        OPEN,\n        COMPLETED,\n        PAID\n    }\n    \n    /* state variables  */\n    /**\n     * @dev s_surveys holds all survey data, with the surveyId as the key. \n     * @dev completed surveys stors the surveyIds for all completed surveys\n     * @dev The surveyCreationFee is required for all new surveys.\n     * @dev The surveyCreationFee is for tx fees and revenue for the service\n     */\n    address i_owner;\n    mapping (string=>Survey) s_surveys;\n    string[] private s_completedSurveys;\n    uint256 private immutable i_surveyCreationFee;\n    uint256 private s_feeHolder;\n\n    /* survey variables  */\n    uint256 private immutable i_interval;\n\n    /* modifiers */\n    modifier onlyOwner(){\n        if (msg.sender != i_owner) revert Surpay__NotOwner();\n        _;\n    }\n\n    /* constructor */\n    constructor(uint256 _surveyCreationFee, uint256 _interval){\n        i_owner = msg.sender;\n        i_surveyCreationFee = _surveyCreationFee;\n        i_interval = _interval;\n    }\n\n    /* events */\n    event SurveyCreated(string indexed surveyId);\n    event UserAddedToSurvey(address indexed surveyTaker);\n    event SurveyCompleted(string indexed surveyId);\n    event SurveyTakersPaid(string indexed surveyId);\n    event FundsWithdrawn(uint256 indexed amount);\n    \n\n    /* functions */\n    /**\n     * @dev chainlink automation. perform upkeep fires if checkUpkeep returns\n     * @dev true.\n     */\n    function performUpkeep(bytes calldata /* performData */) external override{\n        (bool upkeepNeeded, ) = checkUpkeep(\"\");\n        // logic for what should happen if upkeepNeeded is true\n        if (upkeepNeeded) {\n            string[] memory completedSurveys = s_completedSurveys;\n            for (uint256 i=0;i<completedSurveys.length;i++){\n            distributeFundsFromCompletedSurvey(i);\n            emit SurveyTakersPaid(completedSurveys[i]);\n        } \n        } else {\n            revert Surpay__UpkeepNotNeeded();\n        }\n    }\n    /**\n     * @dev Returns true only if there are any complete surveys.\n     */\n    function checkUpkeep(bytes memory /* checkData */) public returns (bool upkeepNeeded, bytes memory /* performData */){\n        // conditions for automation to be performed\n        if (s_completedSurveys.length > 0){\n            upkeepNeeded = true;\n        } else {\n            upkeepNeeded = false;\n        }\n    }\n    /**\n     * @dev A survey can be created by anyone, but it must be called\n     * @dev with both the total payout amount and the survey creation\n     * @dev fee. The current fee is 0.01 ETH. \n     */\n    function createSurvey(\n        string memory _surveyId,\n        string memory _companyId, \n        uint256 _totalPayoutAmount, \n        uint256 _numOfParticipantsDesired\n        ) public payable {\n            if (msg.value < i_surveyCreationFee + _totalPayoutAmount){\n                revert Surpay__NotEnoughFunds();\n            }\n\n            s_feeHolder += i_surveyCreationFee;\n  \n            Survey memory newSurvey;\n            newSurvey.companyId = _companyId;\n            newSurvey.companyAddress = msg.sender;\n            newSurvey.totalPayoutAmount = _totalPayoutAmount;\n            newSurvey.numOfParticipantsDesired = _numOfParticipantsDesired;\n            newSurvey.startTimeStamp = block.timestamp;\n            newSurvey.surveyState = SurveyState.OPEN;\n            \n            s_surveys[_surveyId] = newSurvey;\n            emit SurveyCreated(_surveyId);\n    }\n    /**\n     * @notice Function can only be called by the contract owner.\n     * @notice This was neccissary to ensure that the user data was\n     * @notice a valid response to the survey.\n     * \n     * @dev The SurveyCompleted event is the event listener\n     */\n    function sendUserSurveyData(string memory _surveyId, address userAddress) public onlyOwner {\n        \n        if (s_surveys[_surveyId].numOfParticipantsDesired > s_surveys[_surveyId].numOfParticipantsFulfilled) {\n            // Store the user address and increment participantsFulfilled\n            s_surveys[_surveyId].surveyTakers.push(payable(userAddress));\n            s_surveys[_surveyId].numOfParticipantsFulfilled++;\n            // if number of participants is equal to the number of participants desired, change the survey state to COMPLETED. Add to completedSurveys array. \n            if (s_surveys[_surveyId].numOfParticipantsDesired == s_surveys[_surveyId].numOfParticipantsFulfilled) {\n                s_surveys[_surveyId].surveyState = SurveyState.COMPLETED;\n                s_completedSurveys.push(_surveyId);\n                // event listener for Chainlink Automation\n                emit SurveyCompleted(_surveyId);\n            }\n\n            emit UserAddedToSurvey(userAddress);\n            \n\n        } else {\n            revert Surpay__MaximumRespondantsReached();\n        }\n    }\n    \n    /**\n     * @dev The index of s_completeSurveys is passed in from performUpkeep().\n     */\n    function distributeFundsFromCompletedSurvey(uint256 index) public {\n\n        // copy state variable to local varable for payout iteration\n        string[] memory completedSurveys = s_completedSurveys;\n\n        // revert if the survey has already been paid out.\n        if (s_surveys[completedSurveys[index]].surveyState == SurveyState.PAID){\n            revert Surpay__SurveyAlreadyConcluded();\n        }\n\n        // total payout amount is divided between the number of participants\n        uint256 ethToPay;\n        \n        ethToPay = s_surveys[completedSurveys[index]].totalPayoutAmount / s_surveys[completedSurveys[index]].numOfParticipantsFulfilled;        \n        // loop through all user addresses and in the survey struct, and payout the totalPayoutAmount equally\n        for(uint256 i=0;i<s_surveys[completedSurveys[index]].surveyTakers.length;i++){\n            if (ethToPay < address(this).balance){\n                (bool success, ) = s_surveys[completedSurveys[index]].surveyTakers[i].call{value: ethToPay}(\"\");\n                if (!success){\n                    revert Surpay__TransferFailed();\n                }\n            }\n        }\n        s_surveys[completedSurveys[index]].surveyState = SurveyState.PAID;\n        \n    }\n    /**\n     * @dev allows owner to withdraw no more than the survey creation fees.\n     */\n    function withdrawFromFeeHolder(uint256 amount) public onlyOwner {\n        if (amount > s_feeHolder){\n            revert Surpay__NotEnoughFunds();\n        } else {\n            (bool success, ) = i_owner.call{value: amount}(\"\");\n            if (success){\n                s_feeHolder -= amount;\n                emit FundsWithdrawn(amount);\n            } else {\n                revert Surpay__TransferFailed();\n            }\n        }\n    }\n    /**\n     * Allows the owner to perform a clean up of any completed surveys\n     */\n    function removeCompletedSurveys() public onlyOwner {\n        string[] memory completedSurveys = s_completedSurveys;\n        for(uint256 i=0;i<completedSurveys.length;i++){\n            delete(s_surveys[completedSurveys[i]]);\n        }\n    }\n\n    /* view/pure functions  */\n\n    function getOwner() public view returns(address){\n        return i_owner;\n    }\n\n    function getSurveyState(string memory _surveyId) public view returns(SurveyState){\n        if (s_surveys[_surveyId].numOfParticipantsDesired > 0){\n            return s_surveys[_surveyId].surveyState;\n        } else {\n            revert Surpay__SurveyNotFound();\n        }\n        \n    }\n\n    function getFeeHolderAmount() public view returns(uint256){\n        return s_feeHolder;\n    }\n\n    function getSurveyCreationFee() public view returns(uint256) {\n        return i_surveyCreationFee;\n    }\n\n    function getInterval() public view returns(uint256) {\n        return i_interval;\n    }\n\n    function getCompanyId(string memory surveyId) public view returns(string memory){\n        return s_surveys[surveyId].companyId;\n    }\n\n    function getSurveyPayoutAmount(string memory _surveyId) public view returns(uint256){\n        if (s_surveys[_surveyId].numOfParticipantsDesired > 0){\n            return s_surveys[_surveyId].totalPayoutAmount;\n        } else {\n            revert Surpay__SurveyNotFound();\n        }\n    }\n\n    function getSurveyTaker(string memory surveyId, uint256 userIndex) public view returns(address){\n        // add the address of a survey taker\n        if (s_surveys[surveyId].numOfParticipantsDesired > 0){\n            return s_surveys[surveyId].surveyTakers[userIndex];\n        } else {\n            revert Surpay__SurveyNotFound();\n        }\n        \n    }\n    \n    function getLastTimeStamp(string memory surveyId) public view returns(uint256){\n        if (s_surveys[surveyId].numOfParticipantsDesired > 0){\n            return s_surveys[surveyId].startTimeStamp;\n        } else {\n            revert Surpay__SurveyNotFound();\n        }\n    }\n\n    function getPayoutPerPersonBySurveyId(string memory surveyId) public view returns(uint256){\n        if (s_surveys[surveyId].numOfParticipantsDesired > 0){\n            return s_surveys[surveyId].totalPayoutAmount / s_surveys[surveyId].numOfParticipantsDesired;\n        } else {\n            revert Surpay__SurveyNotFound();\n        }\n    }\n}"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AutomationCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AutomationCompatibleInterface {\n  /**\n   * @notice method that is simulated by the keepers to see if any work actually\n   * needs to be performed. This method does does not actually need to be\n   * executable, and since it is only ever simulated it can consume lots of gas.\n   * @dev To ensure that it is never called, you may want to add the\n   * cannotExecute modifier from KeeperBase to your implementation of this\n   * method.\n   * @param checkData specified in the upkeep registration so it is always the\n   * same for a registered upkeep. This can easily be broken down into specific\n   * arguments using `abi.decode`, so multiple upkeeps can be registered on the\n   * same contract and easily differentiated by the contract.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with, if\n   * upkeep is needed. If you would like to encode data to decode later, try\n   * `abi.encode`.\n   */\n  function checkUpkeep(bytes calldata checkData) external returns (bool upkeepNeeded, bytes memory performData);\n\n  /**\n   * @notice method that is actually executed by the keepers, via the registry.\n   * The data returned by the checkUpkeep simulation will be passed into\n   * this method to actually be executed.\n   * @dev The input to this method should not be trusted, and the caller of the\n   * method should not even be restricted to any single registry. Anyone should\n   * be able call it, and the input should be validated, there is no guarantee\n   * that the data passed in is the performData returned from checkUpkeep. This\n   * could happen due to malicious keepers, racing keepers, or simply a state\n   * change while the performUpkeep transaction is waiting for confirmation.\n   * Always validate the data passed in.\n   * @param performData is the data which was passed back from the checkData\n   * simulation. If it is encoded, it can easily be decoded into other types by\n   * calling `abi.decode`. This data should not be trusted, and should be\n   * validated against the contract's current state.\n   */\n  function performUpkeep(bytes calldata performData) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}